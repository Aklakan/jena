/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.sparql.service.enhancer.impl;

import org.apache.jena.graph.NodeFactory;
import org.apache.jena.query.Query;
import org.apache.jena.query.QueryFactory;
import org.apache.jena.query.Syntax;
import org.apache.jena.sparql.algebra.Algebra;
import org.apache.jena.sparql.algebra.Op;
import org.apache.jena.sparql.algebra.op.OpService;
import org.apache.jena.sparql.core.Var;
import org.apache.jena.sparql.engine.binding.Binding;
import org.apache.jena.sparql.engine.binding.BindingFactory;
import org.apache.jena.sparql.exec.QueryExec;
import org.apache.jena.sparql.graph.GraphFactory;
import org.apache.jena.sparql.service.enhancer.impl.BatchQueryRewriter.SubstitutionStrategy;
import org.apache.jena.sparql.service.enhancer.init.ServiceEnhancerInit;
import org.apache.jena.sparql.sse.SSE;
import org.apache.jena.sys.JenaSystem;
import org.junit.Assert;
import org.junit.Test;



public class TestServiceEnhancerRewrite {
    // Ensure extensions are initialized
    static { JenaSystem.init(); }

    @Test
    public void test01() {
        ServiceEnhancerInit.init();

        Query nonScopeRestrictedQuery = QueryFactory.create("""
            SELECT * {
              BIND("foo" AS ?foo)
              SERVICE <cache:loop+scoped:> {
                SELECT ?bar {
                  BIND(?foo AS ?bar)
                }
              }
            }
        """);

        Query scopeRestrictedQuery = QueryFactory.create("""
            SELECT * {
              BIND("foo" AS ?foo)
              SERVICE <cache:loop+scoped:> {
                SELECT ?foo ?bar {
                  BIND(?foo AS ?bar)
                }
              }
            }
        """);

        Binding b1 = MoreQueryExecUtils.evalToBinding(QueryExec.graph(GraphFactory.createDefaultGraph()).query(nonScopeRestrictedQuery).build(), ServiceEnhancerInit::wrapOptimizer);
        Binding b2 = MoreQueryExecUtils.evalToBinding(QueryExec.graph(GraphFactory.createDefaultGraph()).query(scopeRestrictedQuery).build(), ServiceEnhancerInit::wrapOptimizer);

        // FIXME Validate output and remove sysouts!
        System.out.println(b1);
        System.out.println(b2);

//        BatchQueryRewriter rewriter = BatchQueryRewriterBuilder.from(new OpServiceInfo(op), Var.alloc("idx"))
//                .setSequentialUnion(false)
//                .setOrderRetainingUnion(false)
//                .setOmitEndMarker(false)
//                .setSubstitutionStrategy(SubstitutionStrategy.SUBSTITUTE)
//                .build();

    }

    @Test
    public void testFilterNotExists_01() {
//        Op op1 = Algebra.compile(QueryFactory.create(
//                """
//                SELECT * {
//                  VALUES (?this ?x) { <urn:s> <urn:p> }
//                  SERVICE <loop:> {
//                    ?this ?p ?o
//                    FILTER NOT EXISTS { ?this ?x ?y . }
//                  }
//                }
//                """, Syntax.syntaxARQ));


        OpService op = (OpService)Algebra.compile(QueryFactory.create(
            """
            SELECT * {
              SERVICE <loop:> {
                ?this ?p ?o
                FILTER NOT EXISTS { ?this ?x ?y . }
              }
            }
            """, Syntax.syntaxARQ).getQueryPattern());

        // FIXME There is a null element exception when analyzing not exists part
        //       Besides the warning message from, this might have unwanted consequences.
        //       The warning is generated by OpAsQuery which is used for the norm(alized) query.
        //       The normalized query is used in BatchQueryRewriter only for applying order by expressions
        //       - so variables in not exists shouldn't cause any problems - but still the warning should be handled.
        OpServiceInfo opServiceInfo = new OpServiceInfo(op);
        BatchQueryRewriter rewriter = BatchQueryRewriterBuilder.from(opServiceInfo, Var.alloc("idx"))
            .setSequentialUnion(false)
            .setOrderRetainingUnion(false)
            .setOmitEndMarker(false)
            .setSubstitutionStrategy(SubstitutionStrategy.SUBSTITUTE)
            .build();


          Batch<Integer, PartitionRequest<Binding>> batch = BatchImpl.forInteger();
          Var v1 = Var.alloc("this");
          Var v2 = Var.alloc("x");
          Binding b1 = BindingFactory.binding(v1, NodeFactory.createURI("urn:s1"), v2, NodeFactory.createURI("urn:p1"));
          PartitionRequest<Binding> pr1 = new PartitionRequest<>(0, b1, 0, Long.MAX_VALUE);
          batch.put(0, pr1);

          Binding b2 = BindingFactory.binding(v1, NodeFactory.createURI("urn:s2"), v2, NodeFactory.createURI("urn:p2"));
          PartitionRequest<Binding> pr2 = new PartitionRequest<>(1, b2, 0, Long.MAX_VALUE);
          batch.put(1, pr2);

          Op newOp = rewriter.rewrite(batch).getOp();

          Op expectedOp = SSE.parseOp(
          """
          (order ((asc ?idx))
            (union
              (extend ((?idx 0))
                (filter (notexists (bgp (triple <urn:s1> <urn:p1> ?/y)))
                  (bgp (triple <urn:s1> ?p ?o))))
              (union
                (extend ((?idx 1))
                  (filter (notexists (bgp (triple <urn:s2> <urn:p2> ?/y)))
                    (bgp (triple <urn:s2> ?p ?o))))
                (extend ((?idx 1000000000))
                  (table unit)))))
          """);
          String actualOpStr = newOp.toString();
          String expectedOpStr = expectedOp.toString();
          Assert.assertEquals(expectedOpStr, actualOpStr);
    }
}
